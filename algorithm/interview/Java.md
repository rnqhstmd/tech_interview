- JVM의 구조와 Java의 실행방식을 설명해주세요.
    1. 구조
        - 클래스 로더 :  동적으로 클래스를 로딩해주는 역할을 한다.
        - 런타임 데이터 영역 : JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
        - 메서드 영역 : 클래스 멤버 변수 이름, 데이터 타입, 접근 제어자 등 필드 정보와 메서드 정보등이 생성되는 영역
        - 힙 영역 : new 키워드로 생성된 객체와 배열이 생성되는 영역, 효율적인 GC를 위해 Young, Tenured, Permanent 영역으로 나뉨
        - 스택 영역 : 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 생성되는 영역
        - PC 레지스터 : 쓰레드가 생성될 때마다 생성되는 영역
        - 네이티브 메서드 스택 : 자바 이외의 언어로 작성된 코드를 실행할 때 메모리영역으로 C 스택 사용
    2. 자바 실행방식
        1. 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당받는다.
        2. 자바 컴파일러가 자바 소스코드를 읽어 바이트 코드로 변환시킨다.
        3. 클래스 로더를 통해 class 코드를 JVM으로 로딩한다.
        4. 클래스 로더는 동적 로딩을 통해 필요한 클래스를 로딩, 링크하여 런타임 데이터 영역에 배치
        5. 런타임 데이터 영역은 메모리에 올라온 바이트 코드를 실행함(인터프리터 방식)
- GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
    1. GC란
        - Garbage Collection의 약자로, 자바 메모리 관리 방법 중 하나이다. 힙 영역에서 동적으로 할당했던 메모리 중 필요없는 객체를 모아 주기적으로 제거하는 프로세스.
    2. 필요한 이유
        - 한정된 메모리를 효율적으로 사용할 수 있게한다.
        - 개발자 입장에서 메모리 관리, 누수 문제에 대해 신경쓰지 않고 개발에만 집중할 수 있다.
    3. 동작방식
        - Mark & Sweep 알고리즘 : GC는 힙 메모리에 할당된 데이터가 실제로 사용되고 있는 객체인지에 대한 여부를 판단하는 과정이다. 이 과정에서 사용되지 않는 객체들을 메모리에서 해제(
          Sweep)한다.
- 컬렉션 프레임워크에 대해서 설명해주세요.
    1. 컬렉션 프레임워크란
        - 데이터 그룹을 저장하는 클래스들을 표준화한 설계이다.
    2. 장점
        - 객체 지향적이고 재사용성 높은 코드를 사용할 수 있다.
    3. 주요 인터페이스
        - List : 순서 유지, 중복 저장 가능 , ArrayList, Vector, Stack, LinkedList
        - Set : 순서 유지, 중복 저장 안됨 , HashSet, TreeSet
        - List : 키와 값 쌍, 순서 유지 안됨, 중복 저장 안됨, HashMap, HashTable, TreeMap, Properties
- 제네릭에 대해서 설명해주세요.
    - 파라미터 타입이나 리턴 타입에 대한 정의를 미룬다
    - 타입에 대해 유연성과 안정성을 확보한다
    - 런타임 환경에 영향이 없는 컴파일 시점의 전처리 기술이다. = 런타임에 발생할 타입에러를 컴파일 전 검출해준다.
- 애노테이션에 대해서 설명해주세요.
    - 코드 사이에 주석처럼 쓰이며 특별한 기능을 수행하도록 할 수 있다.
- 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
    - 오버로딩 : 메서드 이름은 같으나 매개변수의 유형과 개수가 다르도록한다
    - 오버라이딩 : 상위클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용하는 것, 메서드 이름과 매개변수 유형과 개수도 일치해야한다.
- 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
    - 차이점은 목적이라 할 수 있다. 추상 클래스는 기본적으로 클래스이며 상속, 확장하여 사용하기 위한 것이다. 반면 인터페이스는 해당 인터페이스를 구현한 객체들에 대한 동작을 보장하기 위해 사용된다. 어떤
      객체가 인터페이스를 구현하였다면, 그 객체는 인터페이스의 모든 기능을 다 구현하였음을 보장하는 것이다. 그리고 인터페이스를 통해 객체를 제어할 수 있음을 나타낸다.
- 클래스는 무엇이고 객체는 무엇인가요?
    - 클래스 : 객체를 생성하기 위한 설계도
    - 객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 자신의 속성을 가지고 있고, 다른것과 식별 가능한 것
- 정적(static)이란 무엇인가요?
    - 말그대로 정적, 고정된이란 의미를 가진다
    - static키워드를 가진 변수, 메서드들은 객체에 소속된 멤버가 아닌 클래스 자체에 소속된 멤버이다.
- 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
    - boolean , 1바이트
    - char, 2바이트
    - byte, 1바이트
    - short, 2바이트
    - int, 4바이트
    - long, 8바이트
    - float, 4바이트
    - double, 8바이트
- 접근 제어자의 종류와 이에 대해 설명해주세요.
    - public : 외부 클래스에서 사용 가능
    - protected : 같은 패키지, 자식 클래스에서 사용 가능
    - private : 내부 클래스에서만 사용 가능
- 객체지향에 대해서 설명해주세요.
    - 프로그래밍에서 필요한 데이터를 추상화해 상태와 행위를 가진 객체를 만들고 그 객체들 간 상호작용을 통해 로직을 구성하는 방법
- SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
    1. SRP : 단일 책임 원칙
        - 객체는 오직 하나의 책임을 가짐
    2. OCP : 개방-폐쇄 원칙
        - 객체는 확장엔 개방, 수정엔 폐쇄적이어야한다.
    3. LSP : 리스코프 치환 원칙
        - 자식 클래스는 언제나 부모 클래스를 대체할 수 있다.
    4. ISP : 인터페이스 분리 원칙
        - 클라이언트에서 사용하지 않는 메서드는 사용하지 않아야한다.
    5. DIP : 의존성 역전 원칙
        - 추상성이 높고 안정적인 클래스는 구체적이고 불안정한 구현 클래스에 의존하면 안 된다.
- 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
    - 동일성 : 동일하다는 뜻으로 두 개의 객체가 완전히 같은 경우를 의미한다. 여기서 완전히 같다는 것은 두 객체가 하나의 객체로 봐도 무방하며 주소값이 같기에 같은 객체를 가리키게된다. ⇒ == 연산자로
      판별한다.
    - 동등성 : 동등하다는 것으로 두 개의 객체가 같은 정보를 담고 있을 경우를 의미한다. 동등성은 변수가 참조하고 있는 객체의 주소가 다르더라도 내용이 같으면 동등하다고 얘기할 수 있다. ⇒ equals
      연산자로 판별할 수 있다.
- 원시타입과 참조타입의 차이에 대해 설명해주세요.
    - 원시 타입 : 정수, 실수, 문자, 논리 리터럴 등 실제 데이터 값을 저장하는 타입이다. int a = 1;와 같이 작성했다면 정수값이 할당될 수 있는 a라는 이름이 메모리 공간이 JVM 스택 영역에
      생성되고, 10이라는 값이 들어간다. 원시 타입은 메모리 공간의 실제 데이터 값이 저장되어있는 것.
    - 참조 타입 : 기본타입을 제외한 타입으로 객체의 주소를 저장하는 타입이다. 문자열, 배열, 열거형 상수, 클래스, 인터페이스 등이 있다. Java에서 실제 객체는 JVM 힙 영역에 저장되며, 참조 타입
      변수는 실제 객체의 주소를 JVM 스택 영역에 저장한다. Person p = new Person(); 이라는 코드를 작성했다면 p라는 이름의 메모리 공간이 스택 영역에 생성되고, 생성된 p의 인스턴스는 힙
      영역에 생성된다. 스택 영역에 생성된 참조 변수 p는 힙 영역에 생성된 p 인스턴스 주소값을 가지게 된다.
- String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
    - 핵심적인 것은 String은 immutable(불변), StringBuffer는 mutable(변함)에 있다.
    - String : 문자열을 대표하는 것으로, 문자열을 조작하는 경우 사용한다. 문자열, 숫자, char등은 concat할 때 StringBuilder, StringBuffer을 사용할 수 있다. 단순한
      경우엔 + 로 붙여쓰면된다. String 객체는 한번 생성되면 할당된 메모리 공간이 변하지않는다. + 를 통해 다른 문자열을 붙여도 기존에 붙이는 것이 아닌 새로운 String을 만든 후 새 String
      객체에 연결된 문자열을 저장하고 참조하게 바꾸는 것이다. String은 이러한 이유때문에 연산이 많은 경우 성능이 좋지 않다.
    - StringBuffer/StringBuilder : 문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우, 기존의 버퍼 크기를 늘리며 유연하게 동작한다. 두 클래스의 차이점은 동기화 여부에 달렸다.
      StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하며, 멀티스레드 환경에서도 동기화를 지원한다. StringBuilder는 동기화를 보장하지 않는다. 따라서 단일 스레드
      환경이라면 StringBuilder를 사용하는 것이 좋다. 단일 스레드 환경에서 StringBuffer를 사용한다고 문제되는 것은 아니지만, 동기화 처리로 인해 StringBuilder보다 성능이 좋지
      않다.
    - String은 짧은 문자열을 더할 때 사용!
    - StringBuffer는 스레드에 안전한 프로그램 사용 시나, 개발 중인 시스템이 스레드에 안전한지 모를 경우 사용!
    - StringBuilder는 스레드에 안전한지 여부가 관계없는 프로그램 개발시 사용!
- Checked Exception과 Unchecked Exception에 대해 설명해주세요.
    - Java의 예외엔 Checked와 Unchecked로 나뉜다.
    - Checked Exception : RuntimeException을 상속하지 않으며, 컴파일 시점에 컴파일러에서 확인하는 예외이고, 반드시 예외 처리를 해야만하는 특징을 가지고 있다.
    - Unchecked Exception : RuntimeException을 상속하는 클래스이고, 런타임 단계에서 확인 가능하며, 예외 처리를 강제하지 않는다는 특징을 가지고 있다. 따라서 컴파일 시
      컴파일러에서 확인하지 않는 예외이다.
- 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
    - Unchecked Exception이 발생시 roll-back한다.
- Java8에서 추가된 기능에 대해서 설명해주세요.
    - 람다식
    - Optional
    - Stream API
    - default method
    - Funtional Interface 어노테이션
    - Date/Time API(LocalDate, LocalTime, LocalDateTime)
    - Method references
- try-with-resource에 대해서 설명해주세요.
    - java 7이상부터 사용후 반납해주어야하는 자원들을 자동으로 반납해주는 기능
    - AutoCloseable 인터페이스를 구현하고 있는 자원들에 대해서 적용이 가능하다.
- 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
    - 강한 결합 : 구현한 클래스를 직접 참조하는 것
    - 느슨한 결함 : 클래스 간 결합력이 낮다는 의미로, 추상화나 인터페이스에 의존한다.
- 직렬화와 역직렬화에 대해서 설명해주세요.
    - 직렬화 : 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템으로 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술
        - Java에서 입출력은 스트림이라는 데이터 통로로 이동하는데, 객체는 바이트형이 아니라 스트림을 통해 파일을 저장하거나 네트워크에 전송할 수 없다.
        - 따라서 객체를 스트림을 통해 입출력하려면, 바이트 배열로 변환하는 것이 필요하다. 이것을 직렬화라고 한다.
        - 시스템적으로는 JVM의 메모리에 상주되어있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태를 말한다.
    - 역직렬화 : 반대로 스트림을 통해 직렬화된 객체를 원래 모양으로 만드는 것을 역직렬화라고 한다.
- 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.

  ### 멀티스레드와 싱글스레드

    - 싱글 스레드 : 애플리케이션이 스레드 하나로만 실행되는 것을 의미한다.
    - 멀티 스렌드 : 애플리케이션이 여러 개의 스레드로 실행되는 것을 의미한다.

  | 싱글 스레드 | 멀티 스레드 |
        | --- | --- |
  | 하나의 스레드이기에 컨텍스트 스위칭 X | 빈번한 컨텍스트 스위칭으로 성능 저하 |
  | 동기화 이슈 X | 스레드 간 동기화 이슈 O |
  | CPU 멀티 코어 사용 불가능 | CPU 멀티코어 병렬성으로 성능 향상 |
  | 순차적 실행으로 응답성 및 전체 처리량 낮음 | 동시성으로 사용자에게 응답성 향상 |

  ### 동시성 이슈

    - 여러 스레드가 동시에 공유 자원에 대해 접근하여 발생하는 문제이다. 따라서 멀테 스레드 환경에서 발생된다.
    - 동시성을 제어하기 위해 암시적 Lock, 명시적 Lock, 스레드에 안전한 객체를 사용하는 것등의 방법이 있다.

- Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.

  ### Mutable(가변객체) 속성

    - heap 영역에 생성된 객체를 변경할 수 있다.
    - 예시 : List, ArrayList, HashMap, StringBuilder, StringBuffer 등
    - 멀티 스레드 환경에서 사용하려면 별도의 동기화 처리가 필요하다.
        - StringBuffer에 할당된 후 StringBuilder의 값을 abc에서 abcdef로 변경했을 때 메모리 주소 값이 변경되지 않았다. 이는 곳 이 메모리 주소에 할당된 값이 abcdef로 변경됐다는 것을 알 수 있다. ⇒ 기존의 수정사항을 바로 반영하기에 Mutable하다는 것.

  ### Immutable(불변 객체) 속성

    - 변경이 불가능하다.
    - String, Boolean, Integer, Float, Long 등
    - 불변 객체를 생성하면 heap 영역에 객체가 생성될 것이고, 이 주소값을 가지는 변수가 스택에 생긴다. ⇒ 즉 불변 객체는 이 객체에 대한 값을 heap 영역에서 수정할 수 없다는 것!
        - str 변수에 값을 할당한 후 값을 변경했을 때 메모리 주소값도 변경된다. 즉 처음에 할당한 메모리 주소의 값이 변경된 것이 아닌 새로운 메모리 주소에 값을 할당하여 값이 수정된 게 아니라 새로 생성된 것이다. 즉 heap에서 새로운 값을 가진 객체를 생성한 것이고, 이에 따라 주소값도 변경되었다.

  ### 차이점

    - 가변객체는 값 수정이 가능하고, 불변객체는 불가능
    - 가변객체는 값을 변경할 수 있는 메서드를 제공하지만, 불변객체는 그런거 없다.
    - mutable class는 getter setter이 존재하지만, immutable class는 그런거 없다.
    - 가변객체는 스레드 safe하지 않을 수 있다(병럴처리 값 보장 못함) 하지만 불변객체는 스레드 safe하다.
- 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.

  ### null 이란?

    - Null은 값이 할당되지 않은 변수라는 의미이다.

  ## null을 안전하게 다루는 방법

  ### 자바 기본 장지

    1. 단정문 (Assertion)
        - Assertion은 부울식(Expression)을 포함하고 있는 문장으로, 그 문장이 실행될 경우 boolean식이 참이라고 단언할 수 있음.
        - 즉 개발자가 본인의 코드에서 가정한 사실이 올바른지 검사가 가능하다.
        - Assertion은 예외 처리가 아닌 검사 기능이다.
        - Assertion을 통해 개발자가 의도한 조건이나 변수 값, 자료형을 검증, 검사할 수 있다.
    2. Java.util.Objects
        - isNull(Object obj)
        - nonNull(Object obj)
        - requireNonNull(T obj)
        - requireNonNull(T obj, String message)
        - requireNonNull(T obj, Supplier<String> messageSupplier)
    3. Optional 사용

  ### null 잘 쓰는 방법

    - API에 null 쓰지 말자
    - null 반환하지 말자
    - 사전조건과 사후조건을 항상 확인하자
    - null의 범위를 클래스, 메서드같은 지역에 제한해두자.
    - 초기화는 명확하게.

  ### null에 안전하다고 보장하는 도구

    - Optional 사용
    - NonNull, Nullable 어노테이션 사용
- JDK와 JRE의 차이점을 설명하세요.

  ### JRE(Java Runtime Environment)

    - JRE란 자바실행환경으로 자바 프로그램을 돌리는데 필요한 것이다.
    - 즉 자바 프로그램만 실행하는데에는 문제 없지만 자바 프로그램을 코딩(개발)할 때 컴파일 에러가 날 수 있다.

  ### JDK(Java Development Kit)

    - 자바 개발 키트이다. 자바를 개발하는데 필요한 기능들이 들어간 것!
    - jdk에도 jre가 포함되어있지만, 자바 프로그램 개발을 위해선 JDK를 다운로드 받아 컴파일 돌려야한다.

  ### 차이점

    - 즉 자바 프로그램을 실행시키는 데 필요한 것 ⇒ JRE
    - 자바 프로그램을 코딩(개발)할거라면 ⇒ JDK, JDK를 다운로드받으면 JRE도 포함되어있어 실행하는 것도 가능하다.