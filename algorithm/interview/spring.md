- Spring DI/IoC는 어떻게 동작하나요?
    - IoC, Inversion of Control 제어의 역전
        - IoC은 프로그램의 제어 흐름을 직접 제어하는 것이 아닌 외부에서 관리하는 것으로, 코드의 최종 호출은 개발자가 제어하는 것이 아닌 프레임워크 내부에서 결정된대로 이루어진다.
        - Spring IoC 컨테이너는 ApplicationContext 인터페이스를 구현한 클래스이다.
        - ApplicationContext는 설정 파일에서 빈 객체를 정의하고 생성, 관리한다.
        - 프로그램이 ApplicationContext가 설정파일을 읽어들여 빈 객체를 생성하고 의존성을 주입한다.
        - 따라서 개발자는 빈 객체의 생성과 의존성 관리에 대한 코드를 작성할 필요없이 Spring 컨테이너에게 위임할 수 있다.
    - DI Dependency Injection, 의존관계 주입은 스프링 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해준다.
- Spring Bean이란 무엇인가요?
    - 빈 Bean은 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트이다.
    - 즉 스프링 컨테이너가 관리하는 자바 객체를 뜻하며, 하나 이상의 빈을 관리한다.
    - 빈은 인스턴스화된 객체를 의미하며, 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.
    - 빈을 사용하는 이유는 스프링 간 객체가 의존관계를 관리하도록 하는 것에 가장 큰 목적이 있다. 객체가 의존관계를 등록할 때 스프링 컨테이너에서 해당하는 빈을 찾고, 그 빈과 의존성을 만든다.

- 스프링 Bean의 생성 과정을 설명해주세요.
    1. 컴포넌트 스캔
        - 스프링에서 제공하는 @Component 어노테이션을 통해 클래스를 명시하여 컨테이너가 생성될 때 컴포넌트 스캔을 통해 자동으로 빈에 등록할 수 있다.
        - Component, Service, Repository, Controller같은 어노테이션들은 자동으로 Component가 포함되어있다.
    2. 직접 스프링 빈 등록
        - Configuration을 위한 클래스를 만든 후 @Configuration으로 명시하면된다. 그리고 빈으로 등록할 클래스를 @Bean 메서드로 생성한 후 객체를 리턴해주면 된다.

- 스프링 Bean의 Scope에 대해서 설명해주세요.
    - Bean Scope는 기본적으로 빈이 존재하는 범위를 뜻한다.
    - 빈 객체는 기본적으로 singleton의 범위를 가지며 singleton은 스프링 컨테이너의 시작과 종료까지 단 하나의 객체만을 사용하는 방식이다.
- IoC 컨테이너의 역할은 무엇이 있을까요?
    - 컨테이너는 객체의 생명주기를 관리하고, 생성된 인스턴스들에게 추가적인 기능을 제공하는 것
    - 스프링 프레임워크도 객체를 생성, 책임지고 의존성을 관리해주는 컨테이너가 있는데, 이게 IoC컨테이너이다.
    - 역할은 인스턴스 생성부터 소멸까지 인스턴스 생명주기 관리를 개발자가 아닌 컨테이너가 대신 해준다. 객체 관리의 주체가 프레임워크이기때문에 개발자는 로직에 집중할 수 있는 장점이 있다.
        - 객체의 생성을 책임지고 의존성을 관리한다
        - POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다. (POJO, Plain Old Object는 주로 특정 자바 모델이나 기능, 프레임워크를 따르지 않는 Java Object를 지칭한다. Java Bean 객체가 대표적이다. 간단하게 getter setter를 생각하면된다.)
        - 개발자들이 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.
        - 개발자는 비즈니스 로직에 집중할 수 있다.
        - 객체 생성 코드가 없으므로 TDD가 용이하다.
    - IoC 컨테이너 종류는 BeanFactory(Bean을 관리한다는 의미의 컨테이너)와 ApplicationContext(BeanFactory에 여러컨테이너 기능을 추가한버전) 가 있다.
        - BeanFactory : BeanFactory 계열의 인터페이스만 구현한 클래스는 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공한다. 보통은 BeanFactory를 사용하지 않고, ApplicationContext를 사용한다.
        - ApplicationContext : Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같지만, 스프링의 각종 부가 기능을 추가로 제공한다.
            - 국제화가 지원되는 텍스트 메세지를 관리해준다.
            - 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공해준다.
            - 리스너로 등록된 빈에게 이벤트 발생을 알려준다.
- DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
    - DI, Dependency Injection으로, 각 클래스 간 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것이다.
        - Setter Injection 수정자 주입
        - Constructor Injection 생성자 주입
        - Method Injection 필드 주입
- Autowiring 과정에 대해서 설명해주세요.
    - 스프링의 Autowiring은 의존성 주입을 의미한다. 이는 스프링 컨테이너가 빈을 생성하고 관리할 때, 자동으로 해당 빈이 필요로 하는 의존성을 찾아 주입해주는 기능이다. Autowiring은 XML 설정, 어노테이션, 자바 설정등으로 구현할 수 있다.
    - 과정
        1. 의존성 확인 : 스프링 컨테이너는 빈을 생성할 때 해당 빈이 필요로 하는 모든 의존성을 확인한다.
        2. 매칭 : Autowiring 설정에 따라 스프링은 의존성을 찾아 적절한 빈을 주입한다. 여러 빈이 있을 경우 매칭 규칙에 따라 적절한 빈을 선택한다.
        3. 의존성 주입 : 선택된 빈이나 빈들이 해당 빈으로 자동으로 주입된다. 방식은 Autowiring 설정에 따라 다르고, 주로 생성자 주입, 세터 주입, 필드 주입이 사용된다.
    - Autowiring은 어노테이션을 사용하여 @Autowired, @Qualifier, @Resource 등을 사용하여 의존성을 주입할 수 있다.
    - 이를 통해 빈의 의존성을 명시하여 설명하지 않아도 되어 코드 유지보수성과 확장성이 좋아진다. 하지만 Autowiring을 남용한다면 코드의 가독성이 떨어지고 의존성이 모호해질 수 있기에 적절한 사용법을 익혀야한다.
- Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
    - DispatcherServlet

      Dispatcher Servlet에 있는 dispatch는 “보내다”라는 뜻이다. HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러로 보내주는 역할을 하는 프론트 컨트롤러이다. 즉 프론트 컨트롤러로서 클라이언트로부터 어떠한 요청이 오게되면 모든 요청을 받아 세부 컨트롤러에 전달하는 역할을 한다.

- 프론트 컨트롤러 패턴이란 무엇인가요?

  요청 경로마다 서블릿을 설정해주는 것은 핸들러마다 공통된 로직을 중복 작성한다는 비효율적인 측면이 있다. (공통된 로직이라함은 한글인코딩처리같은) 서블릿을 개별적으로 나누어 공통된 로직을 중복으로 작성하는 게 아닌 하나의 서블릿으로 앞단에서 다 처리해주는 것이다.

  이렇게 프론트 컨트롤러 패턴을 사용하면, 컨트롤러를 구현할 때 직접 서블릿을 다루지 않아도 되며, 공통 로직 처리가 가능하다. 우리가 스프링 개발을 해오면서 프론트 컨트롤러 패턴을 따르기 때문이다.

- Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
    1. 필터
        - 필터는 말 그대로 요청과 응답을 거른뒤 정제하는 역할을 한다.
        - Dispatcher Servlet에 요청이 전달되기 전 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공한다.
        - 즉 스프링 컨테이너가 아닌 톰켓과 같은 웹 컨테이너에 의해 관리가 되는 것으로, 스프링 범위 밖에서 처리되는 것이다.
        - 사용 사례
            - 보안 인증/인가 관련 작업
            - 모든 요청에 대한 로깅 검사
            - 이미지/데이터 압축 및 데이터 인코딩
            - Spring과 분리되어야하는 기능
    2. 인터셉터
        - 모든 요청에 대한 작업 전/후로 가로챈다고 보면 된다.
        - 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트 안에서 동작한다.
        - 인터셉터는 클라이언트 요청과 관련되어 전연적으로 처리해야하는 작업을 처리할 수 있다.
        - 사용 사례
            - 세부적인 보안 인증/인가 공통 작업
            - API 호출에 대한 로깅 및 검사 (HttpServletResponse, HttpServletRequest 이용)
            - Controller에 넘겨주는 정보(데이터) 가공
    3. 둘의 차이점
        - 필터는 Request와 Response를 조작할 수 있지만, 인터셉터는 조작할 수 없다.

-

### CORS, Cross-Origin Resource Sharing이란

    - 교차 출처 리소스를 의미한다. 즉 다른 출처 간 자원을 공유하는 정책이다.

### 동작 과정

    1. 기본적인 흐름
        - 웹 클라이언트 애플리케이션이 다른 출처의 리소르를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되고, 이때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 담아준다.
    2. Origin
        - 출처를 담아 서버로 보내면, 서버는 응답 헤더의 Access Control Allow Original이라는 값에 이 리소스를 접근하는 것이 허용된 출처 목록을 담아준다. 이후 응답을 받은 브라우저는 자신의 요청 Origin과 서버의 Access Control Allow Original를 비교한 후 같지 않다면 CORS 위반 이슈가 발생된다.
    3. Preflight Request
        - 일반적으로 사용하는 방식
        - 브라우저는 요청을 한 번에 보내는 게 아닌 예비 요청과 본 요청을 나눠 보내는데, 이때 예비 요청은 Options 메서드로 구성되어 리소스가 안전한지 확인하는 정찰병 역할을 한다.

### CORS 예외 해결방법

    - CORS 설정 추가 : 이를 위해 WebMvcConfigurer를 구현하고 addCorsMappings 메서드를 오버라이드하여 CORS 구성을 추가
    - @CrossOrigin 어노테이션 사용 : 컨트롤러 클래스난 메서드에 사용하여 CORS를 허용할 출처와 HTTP 메서드를 지정할 수 있다.
    - CorsFilter 사용 : CorsFilter를 사용하여 모든 요청에 대해 CORS 정책을 적용할 수 있다.
- Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
    - @Component : 개발자가 생성한 class를 기반으로 실행 시점에 인스턴스 객체를 1회(싱글톤) 생성한다. ⇒ @Controller, @Service, @Repository 는 모두 @Component 이며 실행 시점에 자동으로 의존성을 주입해준다.
    - @Bean : 개발자가 작성한 메서드를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성
    - 즉 차이점은 클래스를 기반하냐, 메서드를 기반하냐 차이이고 둘 다 실행 시점에 인스턴스 객체로 1회(싱글톤) 생성한다는 건 같다.
- POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?

  POJO Plain Old Java Object는 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

  프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않는 단순한 클래스로, Java에서 제공되는 API 외에 종속되지 않는다.

  스프링 애플리케이션은 IoC/DI, AOP, PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 기능이다.

- Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?
    - 생성한 Controller 클래스에 대한 정보가 JVM 메모리 영역 중 Method Area, 메서드 영역에 올라가기 때문.
    - Controller 객체는 Heap 에 생성되지만, 해당 클래스의 정보(메서드 로직, 명령)들은 Method Area에 생성된다.
    - 결국 모든 스레드가 객체의 메서드를 공유할 수 있기에 Controller은 1개만 생성된다.

  ### Controller 1개는 어떻게 여러개의 요청을 처리하냐?

  Request 별로 스레드가 생성되고, 각각 ServletContext를 갖는데 어떻게 Controller가 1개만 생성되는 것인가?

    - Singleton인 Controller
        - 각각 스레드들은 싱글톤으로 생성된 빈들을 참고하여 일을 한다. (빈은 기본적으로 싱글톤으로 생성되고 관리된다.
        - 사실상 스레드들은 1개의 싱글톤 컨트롤러 객체를 공유하기에 1개의 Controller만 사용한다는 것이다.
        - 즉 각각의 스레드가 싱글톤으로 생성된 컨트롤러를 참고하여 실행한다고 보면된다.

  ### 자바 메모리 구조
    - 메서드 영역으로는 모든 스레드가 접근 가능하기에 객체의 정보를 공유할 수 잇다.
    - 공유된다해서 동기화될 필요는 없다. 동기화 하는 이유는 프로세스 간 정보의 일치성 문제 때문인데, 컨트롤러가 내부적으로 상태 갖는 게 없으니, 메서드 호출만하면 된다. ⇒ 만약 상태 정보를 갖게된다면 스레드 간 동기화가 필요하고 오버헤드가 발생하게된다.